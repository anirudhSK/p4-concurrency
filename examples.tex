\section{Examples}

With the atomic annotation, the flowlet switching example can now be written in
one of two ways. We later discuss pros and cons of each approach.

\subsection{Using registers}

\begin{verbatim}
control ingress {
  ...
  ...
  apply {
    @atomic{
      apply(flowlet);
      if (ingress_metadata.flow_ipg > FLOWLET_INACTIVE_TOUT) {
          apply(new_flowlet);
      }
    }
    apply(ecmp_group);
    apply(ecmp_nhop);
    apply(forward);
  }
}
\end{verbatim}

This has the correct behavior of \textit{atomically} reading the register
\texttt{flowlet\_id}, and updating it (by incrementing it:
\url{https://github.com/p4lang/p4c/blob/master/testdata/p4_14_samples_outputs/flowlet_switching.p4#L145})
if the condition within the if clause is true. It assumes the standard library
extern element \texttt{register} (\S8.5.2) supports an atomic read and write,
but nothing more.

Underneath, a compiler would have to turn this conditional read-modify-write
into a hardware instruction that atomically updates a piece of memory if a
condition is true. The compiler section of this draft discusses how this
compiler would work.

\subsection{Using more complex extern types}

We could imagine an extern type that provides a thin wrapper around a
hardware instruction that allows a program to atomically increment a state
variable if a boolean condition is true.  A possible declaration for this
extern type is given below.

\begin{verbatim}
extern Conditional++ {
  @atomic void conditional_inc(bool condition);
  @atomic int read();
}
\end{verbatim}

Here, \texttt{conditional\_inc} is declared an atomic method call by the
implementer of the target architecture who specifies the behavior of
\texttt{Conditional++}.  The behavior of \texttt{Conditional++}'s
\texttt{conditional\_inc} method is to atomically increment an internal state
variable if {\texttt condition} is true.

With \texttt{Conditional++}, flowlet switching can now be written as:
\begin{verbatim}
control ingress {
  // Declare a Conditional++ object shared across all control block threads
  Conditional++ conditional++;
  apply {
    conditional++.conditional_inc(ingress_metadata.flow_ipg > FLOWLET_INACTIVE_TOUT);
    apply(ecmp_group);
    apply(ecmp_nhop);
    apply(forward);
  }
}
\end{verbatim}

\subsection{Comparing the two approaches}
The first approach using registers leads to clearer and portable code, because
it only assumes simple registers with atomic read and write capabilities. It
also allows the target implementer to hide potentially propreitary information
regarding how a conditional update is actually implemented, i.e., the target
implementer doesn't need to provide a method that exactly spells out the fact
that it does a conditional increment. With the second approach, the target
implementer needs to specify an external method for every stateful update that
can be carried out using the target's hardware capabilities. This could prove
cumbersome.

 However, the first approach puts the burden on the compiler to figure out
exactly how to translate a block of programmer statements within a
\texttt{@atomic} into hardware instructions. It also leads to the possibility
that the programmer writes code that is rejected because the atomic block is
too large to implement using an atomic hardware instruction and guarantee
atomic semantics. This could be potentially solved by better compiler error
messages telling the programmer how to fix the program, but it adds to compiler
complexity once again.

%TODO: Add more examples from Domino, including ones that don't compile.
