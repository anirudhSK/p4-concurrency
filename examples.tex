\section{Examples}

With the atomic annotation, the flowlet switching example can now be written in
one of two ways. We later discuss pros and cons of each approach.

\subsection{Using registers}

\begin{verbatim}
control ingress {
  ...
  ...
  apply {
    @atomic{
      apply(flowlet);
      if (ingress_metadata.flow_ipg > FLOWLET_INACTIVE_TOUT) {
          apply(new_flowlet);
      }
    }
    apply(ecmp_group);
    apply(ecmp_nhop);
    apply(forward);
  }
}
\end{verbatim}

This has the correct behavior of \textit{atomically} reading the register
\texttt{flowlet\_id}, and updating it (by incrementing it:
\url{https://github.com/p4lang/p4c/blob/master/testdata/p4_14_samples_outputs/flowlet_switching.p4#L145})
if the condition within the if clause is true. It assumes the standard library
extern element \texttt{register} (\S8.5.2) supports an atomic read and write,
but nothing more.

Underneath, a compiler would have to turn this conditional read-modify-write
into a hardware instruction that atomically updates a piece of memory if a
condition is true. \S\ref{s:compiling} discusses how this compiler would work.

\subsection{Using more complex extern objects}

We could imagine an extern object that provides a thin wrapper around a
hardware instruction that allows you to atomically increment a state variable
if a boolean condition is true.  A possible declaration for this
extern object is given below.

\begin{verbatim}
extern Conditional++ {
  @atomic void conditional_inc(bool condition);
  @atomic int read();
}
\end{verbatim}

Here, \texttt{conditional\_inc} is declared an atomic method call by the
implementer of the target architecture who specifies the behavior of
\texttt{Conditional++}.  The behavior of \texttt{Conditional++}'s
\texttt{conditional\_inc} method is to atomically increment an internal state
variable if {\texttt condition} is true.

With \texttt{Conditional++}, flowlet switching can now be written as:
\begin{verbatim}
control ingress {
  // Declare a Conditional++ object shared across all control block threads
  Conditional++ conditional++;
  apply {
    conditional++.conditional_inc(ingress_metadata.flow_ipg > FLOWLET_INACTIVE_TOUT);
    apply(ecmp_group);
    apply(ecmp_nhop);
    apply(forward);
  }
}
\end{verbatim}

\subsection{Comparing the two approaches}
The first approach using registers leads to clearer and portable code, because
it only assumes simple registers with atomic read and write capabilities. It
also allows the target implementer to hide potentially propreitary information
regarding how a conditional update is actually implemented. However, it puts
the burden on the compiler to figure out exactly how to translate a block of
programmer statements within a \texttt{@atomic} into hardware instructions. It
also leads to the possibility that the programmer would write code that is
rejected because the atomic block is too large to implement using an atomic
hardware instruction and guarantee atomic semantics. Again, this could be
potentially solved by better compiler error messages telling the programmer how
to fix the program, but it adds to compiler complexity once again.

%TODO: Add more examples from Domino.
